# Kubernetes Cluster

## Kubernetes Cluster

### Purpose

- Education
    - 교육 목적
    - minikube/cloud/로컬에서 kubeadm
- Development & Testing
    - 단일 마스터가 있는 다중 워커 노드 클러스터
- Hosting Production Application
    - 다중 마스터 노드 클러스터 사용

클러스터는 최대 5000개 노드, 최대 150,000개 파드, 300,000개 컨테이너를 가질 수 있다. 노드 당 최대 100개의 파드를 가질 수 있다.

### Cloud or On-Prem

- 쿠버네티스는 클라우드 또는 온프레미스 환경 모두 사용 가능하다.
- 온프레미스 환경의 경우, kubeadm이 매우 유용하다.
- AWS EKS와 같은 환경을 이용하면 매우 빠르게 클러스터를 프로비저닝할 수 있다.

### Storage

- 고성능 워크로드의 경우 SSD 지원 스토리지를 사용
- 다중 동시 액세스의 경우 네트워크 기반 스토리지
- 여러 파드에서 volume에 대한 공유 액세스의 경우 PV

### Nodes

- Kubernetes 클러스터에서 형성되는 노드는 물리적이거나 가상일 수 있다.
- 물리적 머신이나 가상 머신 또는 클라우드 환경에 배포하도록 선택할 수 있다.

# Kubernetes Hosting Infra

- 쿠버네테스는 다양한 시스템에 다양한 방식으로 배포될 수 있다.
- 요구 사항과 클라우드 생태계 그리고 배포하고자 하는 앱의 종류에 따라 솔루션을 선택할 수 있다.
- 노트북이나 로컬 기기로 시작하는 방법은 여러 가지가 있다. **먼저, 지원되는 Linux 컴퓨터에선 수동으로 바이너리를 설치해** 로컬 클러스터를 설정할 수 있다. (자동화도 가능)
- Windows에서는 Windows 바이너리가 없기 때문에 쿠버네티스를 설정할 수 없다.
- 따라서, Hyper-V나 VMware Workstation, Workshop Box 같은 가상 소프트웨어에 의지해야 한다. Linux VM을 생성해 그 위에 쿠버네티스를 실행할 수 있다.

### Solution

- Minikube는 단일 노드 클러스터를 쉽게 배포한다.
- kubeadm 툴은 하나의 노드 또는 다중 노드 클러스터를 아주 빨리 배포하는 데 사용된다. 하지만 이걸 위해서 필요한 호스트를 지원되는 구성과 함께 직접 프로비저닝해야 한다.
    - kubeadm은 이미 VM이 프로비전된 것을 기대한다.
- 생산 목적으로 쿠버네티스 클러스터를 시작할 때는 사설 또는 공용 클라우드 환경을 사용한다.

---

## HA

- 클러스터 내 모든 컴포넌트에 중복을 갖는 것
- 마스터가 두개인 경우, 어느 쪽이든 요청할 수 있지만 양쪽 다 같은 요청을 해선 안 된다.
- 그래서 API 서버 간의 **트래픽을 분할하는 마스터 노드 앞에 일종의 로드밸런서**를 갖는 게 좋다.
- Kubectl 유틸리티가 로드밸런서를 가리키게 한다.

### scheduler, controller

- 병렬로 실행되면 안되고, **active standby mode로 실행**되어야 한다.
- 선거 과정을 거친다.
- 컨트롤러 매니저 프로세스가 구성되면 **--leader-elect** 옵션을 지정할 수 있다.
- 어떤 프로세스든 해당 정보와 함께 endpoint를 업데이트하는 쪽이 **lease를 획득해 둘 중 하나가 활성화되고, 다른 한 명은 passive**가 된다.

### ETCD

- **stacked control plane nodes topology**
    - etcd가 쿠버네티스 마스터 노드의 일부이다.
    - 한 노드가 다운되면 etcd와 control plane 인스턴스는 둘 다 분실되고 중복은 손상된다.
- **External ETCD**
    - controlplne가 다운되도 etcd 클러스터와 저장된 데이터에 영향을 주지 않는다.
    - 하지만 셋업은 더 어렵고 외부 노드에 대한 서버 수도 두 배가 필요하다.

---

## ETCD

- key value 저장소
- ETCD는 분산되어 있다.
- ETCD는 데이터의 동일한 복사본이 모든 인스턴스에서 동시에 사용 가능하도록 보장한다.
- 대신 한 인스턴스만이 쓰기를 처리한다.
    - 내부에서 두 노드가 선출하는 리더는 하나
    - 전체 인스턴스에서 노드 하나는 리더가 되고 다른 노드는 팔로워가 된다.
    - 쓰기가 리더 노드를 통해 들어오면 리더가 쓰기를 처리하고, 리더가 다른 노드들에게 데이터 복사본을 보낸다.
    - 팔로워 노드를 통해 쓰기가 들어오면 팔로워 노드가 리더에게 쓰기를 전달하고 리더는 쓰기를 처리한다.
    - 쓰기가 처리되면 리더는 쓰기의 복사본이 클러스터의 다른 인스턴스로 분산한다.
- 리더선출 - Raft 알고리즘
    - 무작위로 타이머를 맞춰 신호를 보낸다.
    - 타이머가 먼저 완료된 매니저가 다른 노드에게 리더가 될 권한을 투표한다.
    - 리더로 선출되면 다른 마스터들에게 주기적으로 정기적으로 알림을 보내 자신이 계속 리더의 역할을 하고 있다고 알린다.
    - 다른 노드들이 리더로부터 어떤 시점에 알림을 받지 못할 수도 있다.
        - 리더가 다운되었거나 네트워크 연결이 끊기면!
    - 그러면 노드들 사이에서 재선 프로세스를 시작하고, 새 리더를 선출한다.

---

### Kubeadm

1. 클러스터를 구성하기 위한 여러 시스템 또는 프로비저닝된 가상머신이 필요하다. 시스템이 생성되면 하나의 노드를 마스터로 지정하고 다른 노드는 워커노드로 둔다.
2. 호스트에서 컨테이너 런타임을 설치한다. 우리는 도커를 사용하기에 모든 노드에 도커를 설치해야 한다.
3. 다음 단계는 kubeadm 툴을 모든 노드에 설치한다. kubeadm 툴은 필요한 모든 컴포넌트를 올바른 노드에 올바른 순서로 설치하고 구성하는 쿠버네티스 솔루션 부트스트랩을 지원한다.
4. 다음 단계는 마스터를 초기화한다.
이 과정을 통해 마스터 서버에 필요한 모든 컴포넌트가 설치되고 구성된다. 
5. 마스터가 초기화되면, 워커 노드를 마스터에 결합하기 전에 네트워크 전제조건이 충족되었는지 확인한다. 
6. 워커 노드를 마스터 노드에 조인시킨다.
